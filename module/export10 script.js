/**
 * @author aMediocreDad
 * @copyright Copyright (c) 2021. You are free to use this software for any purpose without fee or charge.
 *
 * @description:
 *  ***********************************
 *  * This script is intended to be   *
 *  * cut and pasted into the console *
 *  * of foundry                      *
 *  ***********************************
 */

/**
 *
 * @constant
 * @type {Object.<string, string>}
 * @description A dictionary used for referencing the entities you'd like to have exported.
 */
const entityTypes = {
  Actor: 'actors',
  Item: 'items',
  JournalEntry: 'journal',
  RollTable: 'tables',
  Scene: 'scenes',
};

/**
 *
 * 	@param {Object.<string, string>} types is supplied the type-list (usually the one declared above).
 *	@return {Object.<string, unknown>} A nested object of all folders and entities in the world. Folder -> Children -> Content.
 */
async function getDirectories(types) {
  const workingTree = {};
  for (const [typeName, type] of Object.entries(types)) {
    workingTree[typeName] = await game[type].directory.tree;
  }
  return workingTree;
}

/**
 *
 * @description Sets the flags of any entity that you later want to link upon import. E.g. rolltable results, journal entry sorting, or scene notes / tokens.
 */
async function setEntityFlags() {
  const journals = game.journal.contents;
  for await (const journal of journals) {
    await setProperty(journal, 'flags.alienrpg-test.folder.sort', journal.sort);
  }
}

/**
 *
 * @param {Object.<string, any>} node A node from the object generated by _getDirectories_.
 * @param {Object.<string, string>} manifestEntry A node in the manifest entry. This object is recursively generated by this function.
 * @param {Object.<string, any>} modulePack Foundry object generated in _createdCompendiums_.
 * @param {String} type Foundry Entity type supplied by referencing the _entityTypes_ object.
 * @description This function recurses upon itself by adding content to the Foundry compendium packs, then generating nodes referencing the created content and their **World**.entity_Id in _manifestEntry_.
 */
async function dirtyWork(node, manifestEntry, modulePack, type) {
  for (const [key, entries] of Object.entries(node)) {
    switch (key) {
      case 'documents':
        if (entries.length > 0) {
          manifestEntry['entities'] = {};
          debugger;
          const preparedEntries = entries.map((e) => e.data);
          const cls = await getDocumentClass(type);
          const createdEntity = await cls.createDocuments(preparedEntries, { pack: modulePack.collection, keepId: true });
          if (entries.length === 1) {
            manifestEntry['entities'][createdEntity[0].data._id] = createdEntity[0].data.name;
          } else if (entries.length > 1) {
            for await (const entry of createdEntity) {
              manifestEntry['entities'][entry.data._id] = entry.data.name;
            }
          } else {
            throw console.error('Failed to add entry to manifest.');
          }
        }
        break;
      case 'children':
        for (const folder of entries) {
          manifestEntry[folder.name] = {
            content: {},
            sorting: folder.sorting ?? 'a',
            sort: folder.sort ?? null,
            color: folder.color ?? null,
          };
          await dirtyWork(folder, manifestEntry[folder.name].content, modulePack, type);
        }
        break;
    }
  }
}

/**
 *
 * @param {String} moduleLabel Label/Title of a top level folder in a given entity type.
 * @param {String} entityType The entity type, used in generating the name of the compendium.
 * @returns A compendium with a name based on the label and the type (to make sure the same root folder name can be reused across entitytypes).
 */
async function createCompendiums(moduleLabel, entityType) {
  moduleLabel = moduleLabel + ' ' + [entityTypes[entityType]];
  const moduleName = moduleLabel
    .replace(/[^A-z0-9\s]/gi, '')
    .replace(/\s/gi, '-')
    .toLowerCase();
  // await game.packs.map(async (pack) =>
  // 	pack.metadata.package === "world"
  // 		? await pack.deleteCompendium()
  // 		: false
  // );
  const createdCompendium = await CompendiumCollection.createCompendium({
    name: moduleName,
    label: moduleLabel,
    type: entityType,
  });
  return createdCompendium;
}

/**
 *
 * @param {Array<string>} entityToCheck An array of names of a given entity type.
 * @param {String} type The supplied entity type that matches {@link entityToCheck}.
 * @returns {Function} Console logs OK!
 * @description Looks for duplicates in a given entity type. It is called before the rest of the script runs.
 */
async function truthFinder(entityToCheck, type) {
  const uniqueNames = [...new Set(entityToCheck)];
  if (uniqueNames.length !== entityToCheck.length) {
    const warning = `Found duplicates in ${type}:`;
    let duplicates = [...entityToCheck];
    uniqueNames.forEach((item) => {
      const i = duplicates.indexOf(item);
      duplicates = duplicates.slice(0, i).concat(duplicates.slice(i + 1, duplicates.length));
    });
    throw console.warn(warning, duplicates);
  } else {
    const green = `%c${type.replace(type[0], type[0].toUpperCase())} contain no duplicates.`;
    return console.info(green, 'color:green');
  }
}

/**
 *
 * @description Ties all functions together, looping over each entitytype in workingTree, and finally printing the manifest.json.
 * If you are exporting several "modules" at once you have to split the resulting manifest.json (I intend to do this automatically at some point);
 */
(async function exportModules() {
  Object.values(entityTypes).forEach(async (type) => {
    const entityToCheck = await game[type].contents.map(({ name }) => name);
    await truthFinder(entityToCheck, type).catch((e) => {
      throw console.error('Found duplicates, exiting!', e);
    });
  });
  for await (pack of game.packs) {
    pack.metadata.package === 'world' ? await pack.deleteCompendium() : null;
  }
  await setEntityFlags();
  const manifestInitialized = {};
  debugger;
  const workingTree = await getDirectories(entityTypes);
  async function loop() {
    for (const entityType in workingTree) {
      manifestInitialized[entityType] = {};
      const rootDir = workingTree[entityType].children;
      if (rootDir.length !== 0) {
        for (const moduleFolder of rootDir) {
          const moduleFolderName = moduleFolder.folder.name;
          const node = moduleFolder;
          manifestInitialized[entityType][moduleFolderName] = {
            content: {},
            sorting: moduleFolder.sorting ?? 'a',
            sort: moduleFolder.sort ?? null,
            color: moduleFolder.color ?? null,
          };
          const manifestEntry = manifestInitialized[entityType][moduleFolderName].content;
          const createdComp = await createCompendiums(moduleFolderName, entityType).catch((e) => {
            error = "Couldn't create compendiums. " + e;
            throw error;
          });
          await dirtyWork(node, manifestEntry, createdComp, entityType);
        }
      }
    }
    return manifestInitialized;
  }
  const finalManifest = await loop().catch((e) => {
    const error = console.error('Looks like something broke:\n', e);
    throw error;
  });
  const print = JSON.stringify(finalManifest);
  saveDataToFile(print, JSON, 'manifest.json');
})();
